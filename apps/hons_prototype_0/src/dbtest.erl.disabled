-module(dbtest).

-export([init/2]).


-include_lib("epgsql/include/epgsql.hrl").

-type query() :: string() | iodata().
-type squery_row() :: tuple(). % tuple of binary().
-type query_error() :: epgsql:connect_error().

-type ok_reply(RowType) ::
{ok, ColumnsDescription :: [epgsql:column()], RowsValues :: [RowType]} | % select
{ok, Count :: non_neg_integer()} |  % update/insert/delete
{ok, Count :: non_neg_integer(), ColumnsDescription :: [epgsql:column()], RowsValues :: [RowType]}. % update/insert/delete + returning
-type error_reply() :: {error, query_error()}.
-type reply(RowType) :: epgsql:ok_reply() | error_reply().

-spec epgsql:squery(connection(), query()) -> reply(squery_row()) | [reply(squery_row())].
%% @doc runs simple `SqlQuery' via given `Connection'
%% squery(Connection, SqlQuery) -> ...

init(Req, Opts) ->
	Method = cowboy_req:method(Req),
	[Action|_] = Opts,
	Req1 = handle(Method, Action, Req),
	{ok, Req, Opts}.

handle(<<"GET">>, dbtest, Req) ->
	io:format("[DEBUG] connected to dbtest~n"),
	{ok, C} = epgsql:connect(#{
	    host => "localhost",
	    username => "bjarne",
	    password => "psssword",
	    database => "mydb",
	    timeout => 4000
	}),
	{ok, Result} = squery(C, SqlQuery),
	io:format("result: ~s~n", [Result]).
